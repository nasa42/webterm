// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FRONTEND_TO_RELAY_MESSAGE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FRONTEND_TO_RELAY_MESSAGE_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FRONTEND_TO_RELAY_MESSAGE_TYPE: [FrontendToRelayMessageType; 2] = [
  FrontendToRelayMessageType::ToAgent,
  FrontendToRelayMessageType::Error,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FrontendToRelayMessageType(pub u8);
#[allow(non_upper_case_globals)]
impl FrontendToRelayMessageType {
  pub const ToAgent: Self = Self(0);
  pub const Error: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ToAgent,
    Self::Error,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ToAgent => Some("ToAgent"),
      Self::Error => Some("Error"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FrontendToRelayMessageType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FrontendToRelayMessageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FrontendToRelayMessageType {
    type Output = FrontendToRelayMessageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FrontendToRelayMessageType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FrontendToRelayMessageType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FrontendToRelayMessageType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FRONTEND_TO_AGENT_MESSAGE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FRONTEND_TO_AGENT_MESSAGE_TYPE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FRONTEND_TO_AGENT_MESSAGE_TYPE: [FrontendToAgentMessageType; 3] = [
  FrontendToAgentMessageType::Data,
  FrontendToAgentMessageType::Error,
  FrontendToAgentMessageType::Resize,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FrontendToAgentMessageType(pub u8);
#[allow(non_upper_case_globals)]
impl FrontendToAgentMessageType {
  pub const Data: Self = Self(0);
  pub const Error: Self = Self(1);
  pub const Resize: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Data,
    Self::Error,
    Self::Resize,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Data => Some("Data"),
      Self::Error => Some("Error"),
      Self::Resize => Some("Resize"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FrontendToAgentMessageType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FrontendToAgentMessageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FrontendToAgentMessageType {
    type Output = FrontendToAgentMessageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FrontendToAgentMessageType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FrontendToAgentMessageType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FrontendToAgentMessageType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RELAY_TO_FRONTEND_MESSAGE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RELAY_TO_FRONTEND_MESSAGE_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RELAY_TO_FRONTEND_MESSAGE_TYPE: [RelayToFrontendMessageType; 2] = [
  RelayToFrontendMessageType::FromAgent,
  RelayToFrontendMessageType::Error,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RelayToFrontendMessageType(pub u8);
#[allow(non_upper_case_globals)]
impl RelayToFrontendMessageType {
  pub const FromAgent: Self = Self(0);
  pub const Error: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FromAgent,
    Self::Error,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FromAgent => Some("FromAgent"),
      Self::Error => Some("Error"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RelayToFrontendMessageType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RelayToFrontendMessageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RelayToFrontendMessageType {
    type Output = RelayToFrontendMessageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RelayToFrontendMessageType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RelayToFrontendMessageType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RelayToFrontendMessageType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RELAY_TO_AGENT_MESSAGE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RELAY_TO_AGENT_MESSAGE_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RELAY_TO_AGENT_MESSAGE_TYPE: [RelayToAgentMessageType; 2] = [
  RelayToAgentMessageType::FromFrontend,
  RelayToAgentMessageType::Error,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RelayToAgentMessageType(pub u8);
#[allow(non_upper_case_globals)]
impl RelayToAgentMessageType {
  pub const FromFrontend: Self = Self(0);
  pub const Error: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FromFrontend,
    Self::Error,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FromFrontend => Some("FromFrontend"),
      Self::Error => Some("Error"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RelayToAgentMessageType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RelayToAgentMessageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RelayToAgentMessageType {
    type Output = RelayToAgentMessageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RelayToAgentMessageType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RelayToAgentMessageType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RelayToAgentMessageType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AGENT_TO_FRONTEND_MESSAGE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AGENT_TO_FRONTEND_MESSAGE_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AGENT_TO_FRONTEND_MESSAGE_TYPE: [AgentToFrontendMessageType; 2] = [
  AgentToFrontendMessageType::Data,
  AgentToFrontendMessageType::Error,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AgentToFrontendMessageType(pub u8);
#[allow(non_upper_case_globals)]
impl AgentToFrontendMessageType {
  pub const Data: Self = Self(0);
  pub const Error: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Data,
    Self::Error,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Data => Some("Data"),
      Self::Error => Some("Error"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AgentToFrontendMessageType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AgentToFrontendMessageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AgentToFrontendMessageType {
    type Output = AgentToFrontendMessageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AgentToFrontendMessageType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AgentToFrontendMessageType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AgentToFrontendMessageType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AGENT_TO_RELAY_MESSAGE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AGENT_TO_RELAY_MESSAGE_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AGENT_TO_RELAY_MESSAGE_TYPE: [AgentToRelayMessageType; 2] = [
  AgentToRelayMessageType::ToFrontend,
  AgentToRelayMessageType::Error,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AgentToRelayMessageType(pub u8);
#[allow(non_upper_case_globals)]
impl AgentToRelayMessageType {
  pub const ToFrontend: Self = Self(0);
  pub const Error: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ToFrontend,
    Self::Error,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ToFrontend => Some("ToFrontend"),
      Self::Error => Some("Error"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AgentToRelayMessageType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AgentToRelayMessageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AgentToRelayMessageType {
    type Output = AgentToRelayMessageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AgentToRelayMessageType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AgentToRelayMessageType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AgentToRelayMessageType {}
pub enum FrontendToRelayMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FrontendToRelayMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FrontendToRelayMessage<'a> {
  type Inner = FrontendToRelayMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FrontendToRelayMessage<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FrontendToRelayMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FrontendToRelayMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<FrontendToRelayMessage<'bldr>> {
    let mut builder = FrontendToRelayMessageBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> FrontendToRelayMessageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FrontendToRelayMessageType>(FrontendToRelayMessage::VT_TYPE_, Some(FrontendToRelayMessageType::ToAgent)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(FrontendToRelayMessage::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for FrontendToRelayMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<FrontendToRelayMessageType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct FrontendToRelayMessageArgs<'a> {
    pub type_: FrontendToRelayMessageType,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for FrontendToRelayMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    FrontendToRelayMessageArgs {
      type_: FrontendToRelayMessageType::ToAgent,
      data: None,
    }
  }
}

pub struct FrontendToRelayMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FrontendToRelayMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: FrontendToRelayMessageType) {
    self.fbb_.push_slot::<FrontendToRelayMessageType>(FrontendToRelayMessage::VT_TYPE_, type_, FrontendToRelayMessageType::ToAgent);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FrontendToRelayMessage::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FrontendToRelayMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FrontendToRelayMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FrontendToRelayMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FrontendToRelayMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FrontendToRelayMessage");
      ds.field("type_", &self.type_());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum FrontendToAgentMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FrontendToAgentMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FrontendToAgentMessage<'a> {
  type Inner = FrontendToAgentMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FrontendToAgentMessage<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FrontendToAgentMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FrontendToAgentMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<FrontendToAgentMessage<'bldr>> {
    let mut builder = FrontendToAgentMessageBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> FrontendToAgentMessageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FrontendToAgentMessageType>(FrontendToAgentMessage::VT_TYPE_, Some(FrontendToAgentMessageType::Data)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(FrontendToAgentMessage::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for FrontendToAgentMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<FrontendToAgentMessageType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct FrontendToAgentMessageArgs<'a> {
    pub type_: FrontendToAgentMessageType,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for FrontendToAgentMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    FrontendToAgentMessageArgs {
      type_: FrontendToAgentMessageType::Data,
      data: None,
    }
  }
}

pub struct FrontendToAgentMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FrontendToAgentMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: FrontendToAgentMessageType) {
    self.fbb_.push_slot::<FrontendToAgentMessageType>(FrontendToAgentMessage::VT_TYPE_, type_, FrontendToAgentMessageType::Data);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FrontendToAgentMessage::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FrontendToAgentMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FrontendToAgentMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FrontendToAgentMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FrontendToAgentMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FrontendToAgentMessage");
      ds.field("type_", &self.type_());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum RelayToFrontendMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RelayToFrontendMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelayToFrontendMessage<'a> {
  type Inner = RelayToFrontendMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RelayToFrontendMessage<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RelayToFrontendMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RelayToFrontendMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<RelayToFrontendMessage<'bldr>> {
    let mut builder = RelayToFrontendMessageBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> RelayToFrontendMessageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RelayToFrontendMessageType>(RelayToFrontendMessage::VT_TYPE_, Some(RelayToFrontendMessageType::FromAgent)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RelayToFrontendMessage::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for RelayToFrontendMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<RelayToFrontendMessageType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct RelayToFrontendMessageArgs<'a> {
    pub type_: RelayToFrontendMessageType,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RelayToFrontendMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    RelayToFrontendMessageArgs {
      type_: RelayToFrontendMessageType::FromAgent,
      data: None,
    }
  }
}

pub struct RelayToFrontendMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RelayToFrontendMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: RelayToFrontendMessageType) {
    self.fbb_.push_slot::<RelayToFrontendMessageType>(RelayToFrontendMessage::VT_TYPE_, type_, RelayToFrontendMessageType::FromAgent);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelayToFrontendMessage::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RelayToFrontendMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RelayToFrontendMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelayToFrontendMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RelayToFrontendMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RelayToFrontendMessage");
      ds.field("type_", &self.type_());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum RelayToAgentMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RelayToAgentMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelayToAgentMessage<'a> {
  type Inner = RelayToAgentMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RelayToAgentMessage<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RelayToAgentMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RelayToAgentMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<RelayToAgentMessage<'bldr>> {
    let mut builder = RelayToAgentMessageBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> RelayToAgentMessageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RelayToAgentMessageType>(RelayToAgentMessage::VT_TYPE_, Some(RelayToAgentMessageType::FromFrontend)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RelayToAgentMessage::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for RelayToAgentMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<RelayToAgentMessageType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct RelayToAgentMessageArgs<'a> {
    pub type_: RelayToAgentMessageType,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for RelayToAgentMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    RelayToAgentMessageArgs {
      type_: RelayToAgentMessageType::FromFrontend,
      data: None,
    }
  }
}

pub struct RelayToAgentMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RelayToAgentMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: RelayToAgentMessageType) {
    self.fbb_.push_slot::<RelayToAgentMessageType>(RelayToAgentMessage::VT_TYPE_, type_, RelayToAgentMessageType::FromFrontend);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelayToAgentMessage::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RelayToAgentMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RelayToAgentMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelayToAgentMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RelayToAgentMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RelayToAgentMessage");
      ds.field("type_", &self.type_());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum AgentToFrontendMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AgentToFrontendMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AgentToFrontendMessage<'a> {
  type Inner = AgentToFrontendMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AgentToFrontendMessage<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AgentToFrontendMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AgentToFrontendMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<AgentToFrontendMessage<'bldr>> {
    let mut builder = AgentToFrontendMessageBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> AgentToFrontendMessageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AgentToFrontendMessageType>(AgentToFrontendMessage::VT_TYPE_, Some(AgentToFrontendMessageType::Data)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(AgentToFrontendMessage::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for AgentToFrontendMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<AgentToFrontendMessageType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct AgentToFrontendMessageArgs<'a> {
    pub type_: AgentToFrontendMessageType,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for AgentToFrontendMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    AgentToFrontendMessageArgs {
      type_: AgentToFrontendMessageType::Data,
      data: None,
    }
  }
}

pub struct AgentToFrontendMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AgentToFrontendMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: AgentToFrontendMessageType) {
    self.fbb_.push_slot::<AgentToFrontendMessageType>(AgentToFrontendMessage::VT_TYPE_, type_, AgentToFrontendMessageType::Data);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AgentToFrontendMessage::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AgentToFrontendMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AgentToFrontendMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AgentToFrontendMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AgentToFrontendMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AgentToFrontendMessage");
      ds.field("type_", &self.type_());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum AgentToRelayMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AgentToRelayMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AgentToRelayMessage<'a> {
  type Inner = AgentToRelayMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AgentToRelayMessage<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AgentToRelayMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AgentToRelayMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<AgentToRelayMessage<'bldr>> {
    let mut builder = AgentToRelayMessageBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> AgentToRelayMessageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AgentToRelayMessageType>(AgentToRelayMessage::VT_TYPE_, Some(AgentToRelayMessageType::ToFrontend)).unwrap()}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(AgentToRelayMessage::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for AgentToRelayMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<AgentToRelayMessageType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct AgentToRelayMessageArgs<'a> {
    pub type_: AgentToRelayMessageType,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for AgentToRelayMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    AgentToRelayMessageArgs {
      type_: AgentToRelayMessageType::ToFrontend,
      data: None,
    }
  }
}

pub struct AgentToRelayMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AgentToRelayMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: AgentToRelayMessageType) {
    self.fbb_.push_slot::<AgentToRelayMessageType>(AgentToRelayMessage::VT_TYPE_, type_, AgentToRelayMessageType::ToFrontend);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AgentToRelayMessage::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AgentToRelayMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AgentToRelayMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AgentToRelayMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AgentToRelayMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AgentToRelayMessage");
      ds.field("type_", &self.type_());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum ResizeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ResizeData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ResizeData<'a> {
  type Inner = ResizeData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ResizeData<'a> {
  pub const VT_COLS: flatbuffers::VOffsetT = 4;
  pub const VT_ROWS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ResizeData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ResizeDataArgs
  ) -> flatbuffers::WIPOffset<ResizeData<'bldr>> {
    let mut builder = ResizeDataBuilder::new(_fbb);
    builder.add_rows(args.rows);
    builder.add_cols(args.cols);
    builder.finish()
  }


  #[inline]
  pub fn cols(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ResizeData::VT_COLS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rows(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ResizeData::VT_ROWS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ResizeData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("cols", Self::VT_COLS, false)?
     .visit_field::<u16>("rows", Self::VT_ROWS, false)?
     .finish();
    Ok(())
  }
}
pub struct ResizeDataArgs {
    pub cols: u16,
    pub rows: u16,
}
impl<'a> Default for ResizeDataArgs {
  #[inline]
  fn default() -> Self {
    ResizeDataArgs {
      cols: 0,
      rows: 0,
    }
  }
}

pub struct ResizeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ResizeDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_cols(&mut self, cols: u16) {
    self.fbb_.push_slot::<u16>(ResizeData::VT_COLS, cols, 0);
  }
  #[inline]
  pub fn add_rows(&mut self, rows: u16) {
    self.fbb_.push_slot::<u16>(ResizeData::VT_ROWS, rows, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ResizeDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ResizeDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ResizeData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ResizeData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ResizeData");
      ds.field("cols", &self.cols());
      ds.field("rows", &self.rows());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `FrontendToRelayMessage`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_frontend_to_relay_message_unchecked`.
pub fn root_as_frontend_to_relay_message(buf: &[u8]) -> Result<FrontendToRelayMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<FrontendToRelayMessage>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `FrontendToRelayMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_frontend_to_relay_message_unchecked`.
pub fn size_prefixed_root_as_frontend_to_relay_message(buf: &[u8]) -> Result<FrontendToRelayMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<FrontendToRelayMessage>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `FrontendToRelayMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_frontend_to_relay_message_unchecked`.
pub fn root_as_frontend_to_relay_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FrontendToRelayMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<FrontendToRelayMessage<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `FrontendToRelayMessage` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_frontend_to_relay_message_unchecked`.
pub fn size_prefixed_root_as_frontend_to_relay_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FrontendToRelayMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<FrontendToRelayMessage<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a FrontendToRelayMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `FrontendToRelayMessage`.
pub unsafe fn root_as_frontend_to_relay_message_unchecked(buf: &[u8]) -> FrontendToRelayMessage {
  flatbuffers::root_unchecked::<FrontendToRelayMessage>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed FrontendToRelayMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `FrontendToRelayMessage`.
pub unsafe fn size_prefixed_root_as_frontend_to_relay_message_unchecked(buf: &[u8]) -> FrontendToRelayMessage {
  flatbuffers::size_prefixed_root_unchecked::<FrontendToRelayMessage>(buf)
}
#[inline]
pub fn finish_frontend_to_relay_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<FrontendToRelayMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_frontend_to_relay_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<FrontendToRelayMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
